# End-To-End Tests: CI for starting a full ETH private network, deploying AVS and running tests.
#
# Overview:
# 1. Start kurtosis network
# 2. Deploy AVS contracts
# 3. Start DataHaven node
# 4. Run E2E tests

name: E2E - Kurtosis Deploy and Verify

on:
  workflow_dispatch:
    inputs:
      image-tag:
        description: "The tag of the docker image"
        required: true
        type: string
  workflow_call:
    inputs:
      image-tag:
        description: "The tag of the docker image"
        required: true
        type: string

permissions:
  contents: read
  packages: read

env:
  FOUNDRY_PROFILE: ci
  LOG_LEVEL: debug
  # DOCKER_HOST: unix:///run/user/1000/docker.sock

jobs:
  kurtosis:
    runs-on:
      group: DH-Testing
    name: E2E Tests with Kurtosis Ethereum Network
    defaults:
      run:
        working-directory: test
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - uses: oven-sh/setup-bun@v2
      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
      - name: Install Kurtosis
        run: |
          # Install Kurtosis locally without sudo
          KURTOSIS_VERSION="1.11.1"
          if ! command -v kurtosis &> /dev/null; then
            echo "Installing Kurtosis $KURTOSIS_VERSION locally"
            mkdir -p ~/.local/bin
            wget -q -O kurtosis-cli.tar.gz "https://github.com/kurtosis-tech/kurtosis-cli-release-artifacts/releases/download/${KURTOSIS_VERSION}/kurtosis-cli_${KURTOSIS_VERSION}_linux_amd64.tar.gz"
            tar -xzf kurtosis-cli.tar.gz -C ~/.local/bin
            rm kurtosis-cli.tar.gz
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            export PATH="$HOME/.local/bin:$PATH"
          else
            echo "Kurtosis is already installed: $(kurtosis version)"
          fi
          kurtosis analytics disable
      - run: kurtosis version
      - uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Cache Foundry libraries
        uses: actions/cache/restore@v4
        with:
          path: ../contracts/lib
          key: ${{ runner.os }}-foundry-libs-${{ hashFiles('.gitmodules') }}
          restore-keys: |
            ${{ runner.os }}-foundry-libs-

      - name: Cache Foundry build artifacts
        uses: actions/cache/restore@v4
        with:
          path: |
            ../contracts/out
            ../contracts/cache
          key: ${{ runner.os }}-foundry-build-${{ hashFiles('contracts/foundry.toml', 'contracts/**/*.sol') }}
          restore-keys: |
            ${{ runner.os }}-foundry-build-
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download snowbridge binary
        run: |
          docker create --name temp datahavenxyz/snowbridge-relay:latest
          mkdir -p tmp/bin
          docker cp temp:/usr/local/bin/snowbridge-relay tmp/bin/
          chmod +x tmp/bin/snowbridge-relay
          docker rm temp
      - run: tmp/bin/snowbridge-relay --help
      - run: docker pull ${{ inputs.image-tag }}
      - run: |
          docker tag ${{ inputs.image-tag }} datahavenxyz/datahaven:local
          docker images
      - run: bun install
      - run: podman info --debug
      - run: bun --version
      - run: bun test:e2e
      # Try to collect all docker logs and upload it
      - name: Collect docker logs
        if: always()
        run: |
          mkdir ./logs
          for name in `docker ps -a --format '{{.Names}}'`; do docker logs $name > ./logs/$name.log 2>&1; done
      - name: Upload logs to GitHub
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: logs
          path: logs/
          retention-days: 1
