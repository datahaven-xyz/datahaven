//! Benchmarks for GRANDPA equivocation reporting.
//!
//! Upstream `pallet-grandpa` only benchmarks `note_stalled`. In DataHaven we also want
//! proper weight coverage for the equivocation reporting extrinsics.
//!
//! The equivocation proof used here is pre-encoded (see `PREENCODED_EQUIVOCATION_PROOF`) and
//! was generated with the same seed as used in setup so that the key owner proof matches.
//! Regenerate with: `cargo test -p pallet-grandpa-benchmarking --features std -- test_generate_equivocation_blob --nocapture`
//!
//! If benchmarks fail with `InvalidEquivocationProof` under frame-omni-bencher, the host may be
//! using a mock or different ed25519 verifier; try running weights via the node's benchmark
//! command instead.

use alloc::{boxed::Box, vec};

use codec::Decode;
use frame_benchmarking::v2::*;
use frame_support::traits::{KeyOwnerProofSystem, OnInitialize};
use frame_system::RawOrigin;
use sp_application_crypto::RuntimeAppPublic;
use sp_runtime::traits::Convert;

use crate::{Config, Pallet};

type GrandpaId = sp_consensus_grandpa::AuthorityId;
type GrandpaEquivocationProof<T> = sp_consensus_grandpa::EquivocationProof<
    <T as frame_system::Config>::Hash,
    frame_system::pallet_prelude::BlockNumberFor<T>,
>;

/// Pre-encoded equivocation proof (set_id=0, round=1) signed with the test vector key.
/// Generated by test_generate_equivocation_blob in lib.rs.
const PREENCODED_EQUIVOCATION_PROOF: [u8; 249] = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 215, 90, 152, 1, 130, 177, 10, 183, 213, 75,
    254, 211, 201, 100, 7, 58, 14, 225, 114, 243, 218, 166, 35, 37, 175, 2, 26, 104, 247, 7, 81,
    26, 225, 44, 34, 212, 241, 98, 217, 160, 18, 201, 49, 146, 51, 218, 93, 62, 146, 60, 197, 225,
    2, 155, 143, 144, 228, 114, 73, 201, 171, 37, 107, 53, 1, 0, 0, 0, 94, 182, 72, 53, 215, 108,
    169, 70, 216, 243, 227, 8, 163, 172, 0, 93, 157, 90, 110, 18, 72, 38, 48, 16, 57, 74, 178, 17,
    106, 150, 24, 107, 195, 175, 45, 40, 156, 45, 67, 202, 120, 13, 87, 252, 21, 17, 62, 155, 246,
    219, 28, 34, 255, 230, 191, 85, 75, 147, 164, 14, 131, 146, 99, 2, 123, 10, 161, 115, 94, 91,
    165, 141, 50, 54, 49, 108, 103, 31, 228, 240, 14, 211, 102, 238, 114, 65, 124, 158, 208, 42,
    83, 168, 1, 158, 133, 184, 2, 0, 0, 0, 151, 111, 43, 192, 22, 148, 165, 193, 112, 145, 172, 94,
    236, 197, 151, 102, 5, 97, 64, 30, 160, 179, 79, 79, 150, 102, 200, 105, 32, 233, 249, 185,
    118, 73, 110, 32, 193, 87, 150, 41, 254, 155, 104, 77, 236, 36, 48, 202, 161, 26, 247, 61, 181,
    109, 221, 114, 165, 70, 43, 146, 198, 158, 253, 1,
];

fn setup_equivocation<T: Config>() -> Result<
    (
        Box<GrandpaEquivocationProof<T>>,
        <T as pallet_grandpa::Config>::KeyOwnerProof,
        <T as frame_system::Config>::AccountId,
    ),
    BenchmarkError,
> {
    use frame_system::pallet_prelude::BlockNumberFor;
    use frame_system::Pallet as System;

    let reporter: T::AccountId = whitelisted_caller();
    frame_system::Pallet::<T>::inc_providers(&reporter);

    // Ensure we are at a sane block number and that session is initialized.
    System::<T>::set_block_number(1u32.into());
    <pallet_session::Pallet<T> as OnInitialize<BlockNumberFor<T>>>::on_initialize(1u32.into());

    // Use the same seed as in test_generate_equivocation_blob so the key matches the
    // pre-encoded proof and the host keystore can store it for KeyOwnerProof.
    let seed = b"0x9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60".to_vec();
    let grandpa_id: GrandpaId = GrandpaId::generate_pair(Some(seed));

    // Install session keys for the reporter account. The runtime provides the concrete
    // `T::Keys` type construction via `Config::benchmark_session_keys`.
    let keys = T::benchmark_session_keys(grandpa_id.clone());
    pallet_session::Pallet::<T>::set_keys(
        RawOrigin::Signed(reporter.clone()).into(),
        keys.clone(),
        vec![0, 1, 2, 3],
    )
    .map_err(|_| BenchmarkError::Stop("set_keys failed"))?;

    let validator_id = T::ValidatorIdOf::convert(reporter.clone())
        .ok_or_else(|| BenchmarkError::Stop("could not convert reporter to ValidatorId"))?;

    // Best-effort: ensure the reporter is treated as a validator for the purposes of generating
    // the key ownership proof. This relies on `pallet_session` internals; if the runtime session
    // manager overwrites these storages, the benchmark will fail and should be adjusted.
    pallet_session::Validators::<T>::put(vec![validator_id.clone()]);
    pallet_session::QueuedKeys::<T>::put(vec![(validator_id, keys)]);

    // Initialize session again after overwriting validator state.
    <pallet_session::Pallet<T> as OnInitialize<BlockNumberFor<T>>>::on_initialize(1u32.into());

    // Generate KeyOwnerProof via Historical (proof identity must match pre-encoded proof).
    let key_owner_proof = pallet_session::historical::Pallet::<T>::prove((
        sp_consensus_grandpa::KEY_TYPE,
        grandpa_id.clone(),
    ))
    .ok_or_else(|| BenchmarkError::Stop("Historical::prove returned None".into()))?;

    // Use pre-encoded equivocation proof (set_id=0). Ensure current_set_id() is 0 so the
    // pallet accepts the proof.
    let proof: GrandpaEquivocationProof<T> =
        Decode::decode(&mut &PREENCODED_EQUIVOCATION_PROOF[..])
            .map_err(|_| BenchmarkError::Stop("failed to decode pre-encoded equivocation proof"))?;

    Ok((Box::new(proof), key_owner_proof, reporter))
}

#[benchmarks]
mod benchmarks {
    use super::*;
    use pallet_grandpa::Call;

    #[benchmark]
    fn note_stalled() -> Result<(), BenchmarkError> {
        let delay = 1000u32.into();
        let best_finalized_block_number = 1u32.into();

        #[extrinsic_call]
        _(RawOrigin::Root, delay, best_finalized_block_number);

        Ok(())
    }

    #[benchmark]
    fn report_equivocation() -> Result<(), BenchmarkError> {
        let (proof, key_owner_proof, reporter) = setup_equivocation::<T>()?;

        #[extrinsic_call]
        _(RawOrigin::Signed(reporter), proof, key_owner_proof);

        Ok(())
    }

    #[benchmark]
    fn report_equivocation_unsigned() -> Result<(), BenchmarkError> {
        let (proof, key_owner_proof, _) = setup_equivocation::<T>()?;

        #[extrinsic_call]
        _(RawOrigin::None, proof, key_owner_proof);

        Ok(())
    }
}
