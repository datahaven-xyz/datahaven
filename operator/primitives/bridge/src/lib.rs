#![cfg_attr(not(feature = "std"), no_std)]

use core::fmt::Debug;
use frame_support::pallet_prelude::*;
use parity_scale_codec::DecodeAll;
use snowbridge_inbound_queue_primitives::v2::{Message as SnowbridgeMessage, MessageProcessor};
use sp_std::vec::Vec;

pub const EL_MESSAGE_ID: [u8; 4] = [112, 21, 0, 56];

#[derive(Encode, Decode, Debug)]
pub struct NewValidatorSet {
    nonce: u64,
    topic: [u8; 32],
    payload: NewValidatorSetPayload,
}

#[derive(Encode, Decode, Debug)]
pub struct NewValidatorSetPayload {
    message_id: [u8; 4],
    message_version: u8,
    command: u8,
    validators: Vec<[u8; 32]>,
    external_index: u64,
}

/// EigenLayer Message Processor
pub struct EigenLayerMessageProcessor<T>(PhantomData<T>);

impl<T, AccountId> MessageProcessor<AccountId> for EigenLayerMessageProcessor<T>
where
    T: pallet_external_validators::Config + Debug,
    <T as pallet_external_validators::Config>::ValidatorId: From<[u8; 32]>,
{
    fn can_process_message(_who: &AccountId, message: &SnowbridgeMessage) -> bool {
        let payload = match &message.xcm {
            snowbridge_inbound_queue_primitives::v2::Payload::Raw(payload) => payload,
            snowbridge_inbound_queue_primitives::v2::Payload::CreateAsset {
                token: _,
                network: _,
            } => return false,
        };
        let decode_result = NewValidatorSet::decode_all(&mut payload.as_slice());
        if let Ok(message) = decode_result {
            message.payload.message_id == EL_MESSAGE_ID
        } else {
            false
        }
    }

    fn process_message(
        _who: AccountId,
        message: SnowbridgeMessage,
    ) -> Result<[u8; 32], DispatchError> {
        let payload = match &message.xcm {
            snowbridge_inbound_queue_primitives::v2::Payload::Raw(payload) => payload,
            snowbridge_inbound_queue_primitives::v2::Payload::CreateAsset {
                token: _,
                network: _,
            } => return Err(DispatchError::Other("Invalid Message")),
        };
        let decode_result = NewValidatorSet::decode_all(&mut payload.as_slice());
        let message = if let Ok(message) = decode_result {
            message
        } else {
            return Err(DispatchError::Other("unable to parse the message payload"));
        };

        let validators: Vec<<T as pallet_external_validators::Config>::ValidatorId> = message
            .payload
            .validators
            .into_iter()
            .map(Into::into)
            .collect();

        pallet_external_validators::Pallet::<T>::set_external_validators_inner(
            validators,
            message.payload.external_index,
        )?;
        let mut id = [0u8; 32];
        id[..EL_MESSAGE_ID.len()].copy_from_slice(&EL_MESSAGE_ID);
        Ok(id)
    }
}

#[cfg(test)]
mod tests {
    use super::*; // Imports NewValidatorSet, NewValidatorSetPayload, EL_MESSAGE_ID from parent module
    use parity_scale_codec::DecodeAll;
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;

    // These constants should match the mock data used in the Solidity test to generate the .bin file
    const MOCK_NONCE: u64 = 12345u64;
    const MOCK_TOPIC_HEX: &str = "123456789012345678901234567890123456789012345678901234567890abcd";
    const MOCK_VALIDATORS_HEX: [&str; 2] = [
        "0000000000000000000000000000000000000000000000000000000000000001",
        "0000000000000000000000000000000000000000000000000000000000000002",
    ];
    const MOCK_EXTERNAL_INDEX: u64 = 0u64; // Corresponds to 'epoch' in Solidity, which was 0

    // Expected fields from the encoded payload part
    // EL_MESSAGE_ID is already defined in the parent module: pub const EL_MESSAGE_ID: [u8; 4] = [112, 21, 0, 56]; // 0x70150038
    const EXPECTED_MESSAGE_VERSION: u8 = 0; // Message.V0 in Solidity
    const EXPECTED_COMMAND: u8 = 0; // OutboundCommandV1.ReceiveValidators in Solidity

    fn hex_to_bytes32(hex_str: &str) -> [u8; 32] {
        let mut arr = [0u8; 32];
        hex::decode_to_slice(hex_str, &mut arr).expect("Failed to decode hex string to bytes32");
        arr
    }

    #[test]
    fn decode_receive_validators_message_from_file_correctly() {
        // Construct the path relative to the Cargo.toml of the dhp-bridge crate.
        // This assumes your operator/primitives/bridge/Cargo.toml is the crate root.
        // And test_data is operator/primitives/bridge/test_data/
        let path = Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("test_data")
            .join("receive_validators_message.bin");

        let mut file = File::open(&path).expect(
            format!("Failed to open message file at {:?}. Please ensure the file exists and was generated by the Solidity test.", path).as_str()
        );
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)
            .expect("Failed to read message file");

        assert!(!buffer.is_empty(), "Message file is empty!");

        let decoded_message = NewValidatorSet::decode_all(&mut buffer.as_slice())
            .expect("Failed to decode NewValidatorSet message from file");

        // Assert top-level fields
        assert_eq!(decoded_message.nonce, MOCK_NONCE, "Nonce mismatch");
        assert_eq!(
            decoded_message.topic,
            hex_to_bytes32(MOCK_TOPIC_HEX),
            "Topic mismatch"
        );

        // Assert payload fields
        let payload = decoded_message.payload;
        assert_eq!(
            payload.message_id, EL_MESSAGE_ID,
            "Payload message_id mismatch with EL_MESSAGE_ID"
        );
        assert_eq!(
            payload.message_version, EXPECTED_MESSAGE_VERSION,
            "Payload message_version mismatch"
        );
        assert_eq!(
            payload.command, EXPECTED_COMMAND,
            "Payload command mismatch"
        );
        assert_eq!(
            payload.external_index, MOCK_EXTERNAL_INDEX,
            "Payload external_index mismatch"
        );

        let expected_validators: Vec<[u8; 32]> = MOCK_VALIDATORS_HEX
            .iter()
            .map(|s| hex_to_bytes32(s))
            .collect();
        assert_eq!(
            payload.validators.len(),
            expected_validators.len(),
            "Validators length mismatch"
        );
        for i in 0..expected_validators.len() {
            assert_eq!(
                payload.validators[i], expected_validators[i],
                "Validator at index {} mismatch",
                i
            );
        }
    }
}
