#![cfg_attr(not(feature = "std"), no_std)]

use frame_support::pallet_prelude::*;
use parity_scale_codec::DecodeAll;
use snowbridge_inbound_queue_primitives::v2::{Message as SnowbridgeMessage, MessageProcessor};
use sp_std::vec::Vec;

pub const EL_MESSAGE_ID: [u8; 4] = [112, 21, 0, 56]; // 0x70150038

#[derive(Encode, Decode)]
pub struct Payload<T>
where
    T: pallet_external_validators::Config,
{
    pub message: Message<T>,
    pub message_id: [u8; 4],
}

#[derive(Encode, Decode)]
pub enum Message<T>
where
    T: pallet_external_validators::Config,
{
    V1(InboundCommand<T>),
}

#[derive(Encode, Decode)]
pub enum InboundCommand<T>
where
     T: pallet_external_validators::Config,
{
    ReceiveValidators {
        validators: Vec<<T as pallet_external_validators::Config>::ValidatorId>,
        external_index: u64,
    },
}

/// EigenLayer Message Processor
pub struct EigenLayerMessageProcessor<T>(PhantomData<T>);

impl<T, AccountId> MessageProcessor<AccountId> for EigenLayerMessageProcessor<T>
where
    T: pallet_external_validators::Config,
{
    fn can_process_message(_who: &AccountId, message: &SnowbridgeMessage) -> bool {
        let payload = match &message.xcm {
            snowbridge_inbound_queue_primitives::v2::Payload::Raw(payload) => payload,
            snowbridge_inbound_queue_primitives::v2::Payload::CreateAsset {
                token: _,
                network: _,
            } => return false,
        };
        let decode_result = Payload::<T>::decode_all(&mut payload.as_slice());
        if let Ok(payload) = decode_result {
            payload.message_id == EL_MESSAGE_ID
        } else {
            false
        }
    }

    fn process_message(
        _who: AccountId,
        message: SnowbridgeMessage,
    ) -> Result<[u8; 32], DispatchError> {
        let payload = match &message.xcm {
            snowbridge_inbound_queue_primitives::v2::Payload::Raw(payload) => payload,
            snowbridge_inbound_queue_primitives::v2::Payload::CreateAsset {
                token: _,
                network: _,
            } => return Err(DispatchError::Other("Invalid Message")),
        };
        let decode_result = Payload::<T>::decode_all(&mut payload.as_slice());
        let message = if let Ok(payload) = decode_result {
            payload.message
        } else {
            return Err(DispatchError::Other("unable to parse the message payload"));
        };

        match message {
            Message::V1(InboundCommand::ReceiveValidators {
                validators,
                external_index,
            }) => {
                pallet_external_validators::Pallet::<T>::set_external_validators_inner(
                    validators,
                    external_index,
                )?;
                let mut id = [0u8; 32];
                id[..EL_MESSAGE_ID.len()].copy_from_slice(&EL_MESSAGE_ID);
                Ok(id)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*; // Imports NewValidatorSet, NewValidatorSetPayload, EL_MESSAGE_ID from parent module
    use parity_scale_codec::DecodeAll;
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;

    // These constants should match the mock data used in contracts/test/MessageEncoding.t.sol
    // Follow the instructions in contracts/test/MessageEncoding.t.sol to generate the .bin file.

    const MOCK_NONCE: u64 = 12345u64;
    const MOCK_TOPIC_HEX: &str = "123456789012345678901234567890123456789012345678901234567890abcd";
    const MOCK_VALIDATORS_HEX: [&str; 2] = [
        "0000000000000000000000000000000000000000000000000000000000000001",
        "0000000000000000000000000000000000000000000000000000000000000002",
    ];
    const MOCK_EXTERNAL_INDEX: u64 = 0u64; // Matchs with epoch in Solidity
    const EXPECTED_MESSAGE_VERSION: u8 = 0; // Message.V0 in Solidity
    const EXPECTED_COMMAND: u8 = 0; // OutboundCommandV1.ReceiveValidators in Solidity

    fn hex_to_bytes32(hex_str: &str) -> [u8; 32] {
        let mut arr = [0u8; 32];
        hex::decode_to_slice(hex_str, &mut arr).expect("Failed to decode hex string to bytes32");
        arr
    }

    #[test]
    fn decode_receive_validators_message_from_file_correctly() {
        let path = Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("test_data")
            .join("receive_validators_message.bin");

        let mut file = File::open(&path).expect(
            format!("Failed to open message file at {:?}. Please ensure the file exists and was generated by the Solidity test.", path).as_str()
        );
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)
            .expect("Failed to read message file");

        assert!(!buffer.is_empty(), "Message file is empty!");

        let decoded_message = NewValidatorSet::decode_all(&mut buffer.as_slice())
            .expect("Failed to decode NewValidatorSet message from file");

        assert_eq!(decoded_message.nonce, MOCK_NONCE, "Nonce mismatch");
        assert_eq!(
            decoded_message.topic,
            hex_to_bytes32(MOCK_TOPIC_HEX),
            "Topic mismatch"
        );

        // Assert payload fields
        let payload = decoded_message.payload;
        assert_eq!(
            payload.message_id, EL_MESSAGE_ID,
            "Payload message_id mismatch with EL_MESSAGE_ID"
        );
        assert_eq!(
            payload.message_version, EXPECTED_MESSAGE_VERSION,
            "Payload message_version mismatch"
        );
        assert_eq!(
            payload.command, EXPECTED_COMMAND,
            "Payload command mismatch"
        );
        assert_eq!(
            payload.external_index, MOCK_EXTERNAL_INDEX,
            "Payload external_index mismatch"
        );

        let expected_validators: Vec<[u8; 32]> = MOCK_VALIDATORS_HEX
            .iter()
            .map(|s| hex_to_bytes32(s))
            .collect();
        assert_eq!(
            payload.validators.len(),
            expected_validators.len(),
            "Validators length mismatch"
        );
        for i in 0..expected_validators.len() {
            assert_eq!(
                payload.validators[i], expected_validators[i],
                "Validator at index {} mismatch",
                i
            );
        }
    }
}