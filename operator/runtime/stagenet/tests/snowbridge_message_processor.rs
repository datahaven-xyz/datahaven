// Copyright 2025 Moonbeam Foundation.
// This file is part of DataHaven.

//! Snowbridge message processor static test for DataHaven stagenet runtime
//!
//! Tests for processing Snowbridge messages through DataHaven

use datahaven_stagenet_runtime::{AccountId, Runtime};
use dhp_bridge::InboundCommand;
use dhp_bridge::Message;
use std::fs;

const MOCK_VALIDATORS_HEX: [&str; 2] = [
    "0000000000000000000000000000000000000001",
    "0000000000000000000000000000000000000002",
];
const MOCK_EXTERNAL_INDEX: u64 = 0u64;

fn hex_to_bytes20(hex_str: &str) -> [u8; 20] {
    let mut arr = [0u8; 20];
    hex::decode_to_slice(hex_str, &mut arr).expect("Failed to decode hex string to bytes20");
    arr
}

#[test]
fn test_eigenlayer_message_processor_with_binary_file() {
    let binary_file_path = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../primitives/bridge/test_data/receive_validators_message.bin");

    // Read the binary file generated by the forge test
    let binary_data = fs::read(&binary_file_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read binary file at {}: {}",
            binary_file_path.display(),
            e
        );
    });

    println!("ğŸ“„ Binary file has {} bytes", binary_data.len());

    if binary_data.len() <= 0 {
        panic!("Binary file corrupted.");
    }

    let payload_data = &binary_data[..binary_data.len()];
    // Log the expected structure breakdown
    println!(
        "ğŸ“Š Expected payload structure ({} bytes):",
        payload_data.len()
    );
    println!("  - EL_MESSAGE_ID: 4 bytes");
    println!("  - Message.V1: 1 byte");
    println!("  - OutboundCommandV1.ReceiveValidators: 1 byte");
    println!("  - validatorsLen (compact): 1 byte");
    println!(
        "  - validatorsFlattened: {} bytes ({} validators Ã— 20 bytes each)",
        payload_data.len() - 15,
        (payload_data.len() - 15) / 20
    );
    println!("  - externalIndex: 8 bytes");

    // Log the actual bytes as hex
    println!("ğŸ” Payload bytes (hex):");
    println!("  Full payload: {}", hex::encode(payload_data));

    // Split and log each expected chunk
    if payload_data.len() >= 4 {
        let message_id = &payload_data[0..4];
        println!("  EL_MESSAGE_ID (bytes 0-3): {}", hex::encode(message_id));
    }

    if payload_data.len() >= 5 {
        let message_version = &payload_data[4..5];
        println!("  Message.V1 (byte 4): {}", hex::encode(message_version));
    }

    if payload_data.len() >= 6 {
        let command = &payload_data[5..6];
        println!(
            "  OutboundCommandV1.ReceiveValidators (byte 5): {}",
            hex::encode(command)
        );
    }

    if payload_data.len() >= 7 {
        let validators_len_compact = &payload_data[6..7];
        println!(
            "  validatorsLen compact (byte 6): {}",
            hex::encode(validators_len_compact)
        );
    }

    // Log validators data
    if payload_data.len() >= 7 {
        let validators_start = 7;
        let validators_end = payload_data.len() - 8; // 8 bytes for external_index at the end
        if validators_end > validators_start {
            let validators_data = &payload_data[validators_start..validators_end];
            println!(
                "  validatorsFlattened (bytes {}-{}): {}",
                validators_start,
                validators_end - 1,
                hex::encode(validators_data)
            );

            // Split into individual validator addresses
            let validator_count = validators_data.len() / 20;
            println!("  Individual validators:");
            for i in 0..validator_count {
                let start = i * 20;
                let end = start + 20;
                let validator = &validators_data[start..end];
                println!("    Validator {}: {}", i, hex::encode(validator));
            }
        }
    }

    // Log external index
    if payload_data.len() >= 8 {
        let external_index_start = payload_data.len() - 8;
        let external_index = &payload_data[external_index_start..];
        println!(
            "  externalIndex (last 8 bytes): {}",
            hex::encode(external_index)
        );
    }

    // Try to decode the payload data directly
    let decoded_result =
        dhp_bridge::EigenLayerMessageProcessor::<Runtime>::decode_message(payload_data);

    match decoded_result {
        Ok(payload) => {
            println!("âœ… Successfully decoded payload data");

            match payload.message {
                Message::V1(InboundCommand::ReceiveValidators {
                    validators,
                    external_index,
                }) => {
                    println!(
                        "ğŸ“Š Decoded {} validators with external_index: {}",
                        validators.len(),
                        external_index
                    );

                    // Create expected validators from MOCK_VALIDATORS_HEX
                    let expected_validators: Vec<AccountId> = MOCK_VALIDATORS_HEX
                        .iter()
                        .map(|s| hex_to_bytes20(s).into())
                        .collect();

                    // Compare decoded validators with expected ones
                    assert_eq!(
                        validators, expected_validators,
                        "Decoded validators from binary file should match MOCK_VALIDATORS_HEX"
                    );
                    assert_eq!(
                        external_index, MOCK_EXTERNAL_INDEX,
                        "External index should match"
                    );

                    println!(
                        "âœ… Binary file test passed - decoded validators match expected values"
                    );
                }
            }
        }
        Err(e) => {
            println!("âŒ Failed to decode payload data: {:?}", e);
            panic!("Failed to decode binary file payload: {:?}", e);
        }
    }
}
